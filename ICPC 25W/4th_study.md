### 누적합 (prefix sum)

배열에서 각 위치까지의 합(또는 값)을 미리 계산하는 기법을 누적합 이라고 한다.

백준 11659번 - 구간 합 구하기 4

f(i) = 구간 [1, i]의 원소를 합친 값

우리는 이 간단한 정의를 통해 아래의 내용을 알아보고자 한다.

    1. 우리가 원하는 것을 구할 수 있는가.
    2. 이걸 구하는 것이 효율적인가.

* f(1) 부터 f(n)까지 우리가 모두 구했다고 가정해보자.

우리는 문제에서 요구하는 구간 [i, j]에 속하는 원소들의 합을 구해야 한다.

이는 f(j)-f(i-1)로 구할 수 있다.

*  f(j) = A[1] + A[2] + … + A[j]이고,
f(i-1) = A[1] + A[2] + … + A[i-1]이므로,
f(j) - f(i-1) = A[i] + A[i+1] … + A[j]가 된다.

f(i)를 naive 하게 구하면, O(n^2)이다.
하지만, 우리는 최적화를 통해 O(n)으로 만들 것이다.

f(i) = 구간 [1, i]의 원소의 합이므로
f(i-1) = 구간 [1, i-1]의 원소의 합이다.

우리가 f(i-1)을 안다면,
f(i) = f(i-1) + A[i]로 O(1)만에 구할 수 있다. (상수 시간 만에 구할 수 있게 되는 것이다.)

그렇기 때문에 f(1) = A[1]이니, 이도 O(1)이다.

모든 f(i)를 구하는데에 
각 f(i)를 구할 때는 O(1)밖에 들지 않고,
총 N개를 구하기 때문에
O(N)으로 f(1)부터 f(n)을 모두 구할 수 있다.
그리고 이것을 prefix sum이라고 부르는 것이다.



+ 2차원도 구할 수 있는가.

백준 11660번 - 구간 합 구하기 5

f(1)부터 f(n)까지 전부 다 구하는데, 행이 여러 개이기 때문에 구분하는 것이 중요하다.

그렇기 때문에 우리는 각 행을 구분할 목적으로 인자를 하나 더 넣는다. f(i, j)

f(i, j) = i 행에 대해서, 구간 [1, j]에 속한 원소의 합이라고 두고 1행부터 n행까지 모두 prefix sum을 구하면 된다.

위와 같이 사각형인 경우에는 구하기 쉽지만, 그렇지 않은 경우에는 누적합을 구하기 어렵다.

그 이유는 우리가 원하는 값이 기준을 포함하지 않기 때문이다. 

결국 prefix sum은 어떠한 기준으로부터 값을 연속적으로 계산한 것이기 때문에, 원하는 값을 얻기 위해서는 값을 제외주어야 한다.

### prefix sum의 한계(1)

+ prefix sum에서 중간에 값이 바뀌면 완전 통째로 수정해야한다.

값이 업데이트 된다면, 그 시점에서부터 다시 누적합을 구성해주어야 한다.

따라서 누적합은 구성에 O(n) 쿼리에 O(1) 업데이트에 최대 O(n)번의 수정을 해야한다.


### prefix sum의 한계(2)

해당 연선에 역연산이 존재해야 한다.

* '역연산'이란 '역원'을 말한다.

+ 역연산이 있다면 특정 구간의 값을 prefix sum으로 구할 수 있다. 
e.g. 구간의 합, 구간의 곱 등등

최댓값이나 최솟값을 구하는 등의 문제에서는 prefix sum을 사용하기에는 어려움이 있다.

관심없는 구간의 값을 제거할 때 문제가 생기게 된다. (역연산이 필요한데, max를 구하는데에 역연산을 구하는데에 어려움이 존재하는 것이 자명하다.)

--> 업데이트가 있거나, 역연산이 존재하지 않는 경우 prefix sum을 적용하기에 어려움이 있다.

백준 2003번 - 수들의 합 2



### two pointer

백준 2003번 - 수들의 합 2

(배열에서) 두 개의 포인터를 사용하여 조건을 만족하는 부분을 찾는 알고리즘을 'two pointer'라고 한다.

* 어떻게 구현하는가.
    1. 두 개의 포인터 위치 설정하기
    2. 조건 검사하기
    3. 포인터 옮기기
    4. 2,3을 반복하기

S와 L이 같은 상황이 발생하게 된다면, 아무거나 이동시키면 된다.


+ two pointer 예제
    ```
    int n,m;cin >> n>> m;
    for(int i=1;i<=n;i++>){
        int s = 0,  ans = 0;
        for(int l=1, r=0;l <= n;l++){
            while(r < n && s<m){
                r++;
                s += A[r];
            }
            if(s==m) ans++;
            s -= A[l];
        }
        cout << ans << endl;
    }
    ```

결국 L, R이 시작지점에서 종료지점까지 이동하면 종료된다.
이동은 L이 O(N)번, R이 O(N)번 할 수 있다.
이동을 할 때마다 조건에 대해서 검사하지만, 검사는 O(1)로 처리한다.
그렇기 때문에 시간복잡도는 O(n)이다.

* 투 포인터는 사용이 제한적이다보니, 자주 나오는 문제 유형이 존재한다.